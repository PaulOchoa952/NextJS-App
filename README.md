# Patient Management System

A Next.js application for managing patient records using Supabase as the backend.

## Features

- üîê Authentication with Supabase Auth
- üë• Patient Management (CRUD operations)
- üìÖ Appointment Scheduling
- üîí Secure Vault for Sensitive Data
- üåô Dark Mode UI
- üöÄ Real-time Updates
- üì± Responsive Design

## Tech Stack

- **Frontend Framework:** Next.js 14 with TypeScript
- **Styling:** Tailwind CSS
- **Database:** Supabase
- **Authentication:** Supabase Auth
- **State Management:** React Context
- **UI Components:** Custom components with Tailwind
- **Form Handling:** React Hook Form
- **Notifications:** React-Toastify

## Prerequisites

- Node.js 18.17 or later
- npm or yarn
- Supabase account and project

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd patient-management-system
 ```
 ```sql

2. Install dependencies:
```bash
npm install
```

3. Set up environment variables:
Create a `.env.local` file in the root directory:
```bash
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

## Database Setup

1. Start Supabase locally with Docker:
```bash
npx supabase start
```

2. Create the database tables in Supabase:

```sql
-- Patients table
create table patients (
  patient_id bigint generated by default as identity primary key,
  first_name text not null,
  last_name text not null,
  date_of_birth date not null,
  gender text,
  contact_number text,
  email text,
  address text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Appointments table
create table appointments (
  appointment_id bigint generated by default as identity primary key,
  patient_id bigint references patients(patient_id),
  doctor_name text not null,
  appointment_date date not null,
  appointment_time time not null,
  reason text,
  status text check (status in ('Scheduled', 'Completed', 'Cancelled')) default 'Scheduled',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
--Access logs table
CREATE TABLE access_logs (
  id SERIAL PRIMARY KEY,
  patient_id INTEGER REFERENCES patients(patient_id), -- Assuming you have a patients table
  action TEXT NOT NULL,
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  api_key_used TEXT NOT NULL
);

-- Indexes
create index idx_appointments_patient_id on appointments(patient_id);
create index idx_appointments_date on appointments(appointment_date);
```

## Development Tools Setup

1. **Plop (Code Generator)**
```bash
npm install --save-dev plop
```

2. **Tailwind CSS**
```bash
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

3. **ESLint & Prettier**
```bash
npm install -D eslint prettier eslint-config-prettier eslint-plugin-prettier
```

4. **Supabase Client**
```bash
npm install @supabase/supabase-js
```

5. **Supabase CLI (for local development)**
```bash
npm install --save-dev supabase
```

## Available Scripts

```bash
# Run development server
npm run dev

# Build for production
npm run build

# Start production server
npm start

# Generate new component
npm run plop component ComponentName

# Generate new service
npm run plop service ServiceName

# Start local Supabase
npx supabase start

# Stop local Supabase
npx supabase stop
```

## Project Structure

```
src/
‚îú‚îÄ‚îÄ app/                    # Next.js app router pages
‚îú‚îÄ‚îÄ components/            # Reusable components
‚îÇ   ‚îî‚îÄ‚îÄ PatientForm/      # Patient form component
‚îú‚îÄ‚îÄ services/             # API services
‚îÇ   ‚îî‚îÄ‚îÄ patientService.ts # Patient CRUD operations
‚îú‚îÄ‚îÄ types/                # TypeScript types/interfaces
‚îÇ   ‚îî‚îÄ‚îÄ patient.ts       # Patient type definitions
‚îú‚îÄ‚îÄ lib/                  # Third-party library configurations
‚îÇ   ‚îî‚îÄ‚îÄ supabaseClient.ts # Supabase client configuration
‚îî‚îÄ‚îÄ styles/               # Global styles
```

## Type Definitions

The application uses TypeScript interfaces for type safety:

```typescript
interface Patient {
  patient_id: number;
  first_name: string;
  last_name: string;
  date_of_birth: string;
  gender: string;
  contact_number: string;
  email: string;
  address: string;
  created_at?: string;
}
```
## Create a policy
1.Go to table editor

2.Click on the table you want to enable the RLS

3.Click on enable RLS policy


## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## Troubleshooting

### Common Issues

1. **Supabase Connection Issues**
   - Verify your environment variables are correctly set
   - Ensure Supabase Docker container is running
   - Check network connectivity

2. **TypeScript Errors**
   - Run `npm run type-check` to verify types
   - Ensure all required fields are included in interfaces

3. **Database Errors**
   - Verify table schema matches type definitions
   - Check Supabase policies are correctly set

4. **pg_crypto Extension Issues**
   - Error: ERROR: 0A000: extension "pg_crypto" is not available DETAIL: Could not open extension control file "/usr/share/postgresql/15/extension/pg_crypto.control": No such file or directory. HINT: The extension must first be installed on the system where PostgreSQL is running.
   - Opciones y soluciones:
       ```sql
       SELECT * FROM pg_available_extensions WHERE name = 'pgcrypto';
       ```
       ![Alt text](/images/image.png)
<!-- Image link removed due to broken path -->
     - Ahora, el siguiente paso es intentar habilitar la extensi√≥n en tu esquema de base de datos. Puedes hacerlo con el siguiente comando SQL:
       ```sql
       CREATE EXTENSION IF NOT EXISTS pgcrypto;
       ```
     - Ejemplo de Inserci√≥n y Cifrado de Datos con pgcrypto:
       - Insertar Datos con Cifrado: Supongamos que tienes una tabla patients con las columnas id, name y encrypted_name, y deseas cifrar el campo name al insertarlo:
         ```sql
         INSERT INTO patients (name, encrypted_name)
         VALUES ('Juan P√©rez', pgp_sym_encrypt('Juan P√©rez', 'my_secret_key'));
         ```
       - Pasos para agregar la columna y almacenar datos cifrados:
         - Agregar la Columna para Almacenar los Datos Cifrados: Primero, debes modificar tu tabla para agregar la nueva columna que almacenar√° los datos cifrados. Puedes hacerlo con el siguiente comando SQL:
           ```sql
           ALTER TABLE patients
           ADD COLUMN encrypted_name bytea;
           ```
         - Insertar Datos Cifrados en la Nueva Columna: Luego, al insertar o actualizar los datos, puedes cifrar el campo name y almacenarlo en la columna encrypted_name usando la funci√≥n pgp_sym_encrypt:
           ```sql
           UPDATE patients
           SET encrypted_name = pgp_sym_encrypt(name, 'my_secret_key');
           ```
         - Si est√°s insertando nuevos datos, se ver√≠a as√≠:
          ```sql
          /* INSERT INTO patients (first_name, last_name,date_of_birth,gender,contact_number,email,address, encrypted_name)
          VALUES ('Juan', 'P√©rez','2024-11-26','Female','555-8765','juan@gmail.com','av.del trabajo#37', pgp_sym_encrypt('Juan P√©rez', 'my_secret_key')); */
          --select*from patients
          ```
       - Recuperar y Descifrar los Datos: Para obtener los datos descifrados, puedes usar la funci√≥n pgp_sym_decrypt en la consulta SQL:
       ```sql
       SELECT first_name, pgp_sym_decrypt(encrypted_name::bytea, 'my_secret_key') as decrypted_name
       FROM patients;
       ```
         ```

CREATE EXTENSION IF NOT EXISTS pg_crypto;

## License

This project is licensed under the MIT License - see the LICENSE file for details


